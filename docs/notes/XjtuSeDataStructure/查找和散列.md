# 查找与散列

> 作者：李彦筱
>
> 感谢学长 [yijunquan](https://github.com/yijunquan-afk) 的[软件工程笔记](https://github.com/yijunquan-afk/XJTUSE-NOTES)给我的启发。此笔记从二叉树开始的部分中使用了学长笔记中的部分图片以及文字。
>

这一部分内容只需要掌握概念即可，不用掌握具体如何用代码实现。

## 查找

定义：根据一个关键字，在一个*查找表*里查找和这个关键字一样的所有元素

分类：

- 静态查找表：只能查找，不能进行元素的插入和删除
- 动态查找表：*查找表*不仅可以查找，还可以插入和删除

### 查找表的各种（可能）实现以及时间复杂度

查找表是一个需要查找和（可选的）插入，删除这三个操作的数据结构。

- 有序数组实现法：

  - 查找： O(logn)
  - 插入：O(n)（因为要找到正确的插入位置，让数组保持有序）
  - 删除：O(n)（因为数组任意位置删除是O(n）)

- 单向链表：

  - 查找：O(n)
  - 插入：O(1)
  - 删除：O(n)

- 二叉检索树：

  - 查找：O(logn)
  - 插入：O(logn)
  - 删除：O(logn)

- 直接寻址表：

  这种表用类似于内存的方法存储数据。假如要存储数据的关键码不重复，则按照关键码把数据存放到数组的[关键码]位置。

  这种方式在关键码很大的时候，需要一张超级大的表，所以空间消耗十分的不能看。

  - 查找：O(1)

    查找时只需要查看数组下标=关键码的位置是谁。

  - 插入：O(1)

    插入时把数据放到数组下标=关键码的时候

  - 删除：O(1)

    删除时删除数组下标=关键码的元素

  这种存储方式的限制：

  - 存储的下标和关键码之间必须有对应元素

  - 空间利用率很低。比如一个关键码为20的元素可能需要一个大小为20的直接寻址表，即使这个表中只有它一个元素。

    这说明了直接把关键字对应到数组下标是一个十分浪费空间的行为。比如，如果用直接寻址表存储我们学校的学生信息，利用学号作为关键码，那么就需要十亿级的数组（学号是10位的），但却仅存储了万级别的数据。这是非常浪费的。

### 散列

散列是对直接寻址法的一种改进，它可以做到：

1. 把直接寻址法的关键字压缩到另一个范围
2. 获得常数级别的查找和插入性能



## 散列

### 散列函数与完美散列函数

Hash function（散列函数）：接受一个待查找的关键码，输出一个数组中的索引。

散列函数是一个“黑盒子”，可以帮助我们完成关键字-数组索引的对应关系。使用散列函数而不是直接把关键码作为数组索引，是因为关键码可能会很大，大到他需要的数组大小是无法接受的。

数组叫做 Hash Table, 返回的数组中的索引叫做 Hash Index

Prefect Hash Function（完美哈希函数）：可以把任何不同的待查找关键字映射到同一个哈希表的不同哈希索引上。这种函数是我们一直追求的函数，不过找到他的难度是非常大的（而且现在似乎还没有找到）

哈希函数返回待查找关键字在数组当中的索引位置；哈希表中这个索引位置的内容是和待查找关键字匹配的记录。

哈希表是一个数组，而哈希函数返回哈希表中的一个索引。哈希函数的工作，即如何把关键码转换为索引，是一个重要的问题。

### 哈希函数的工作

把任何一个关键码转换为索引位置一般经过两步：

1. 如果这个关键码不是整数，就想办法把它转换为一个整数的数据。转换后的结果称为 Hash code （哈希码），不再叫关键字。

   比如，任何一个字节流似乎都可以用md5, sha-1, sha-256等这种算法转换为一个固定大小的十六进制数字。

   这一步骤不在本节课的研究范围内。

2. 把关键码（或者哈希码）转换为数组的索引位置。这一步是任何哈希函数都必须要做的事，我们即将学习。

   实现这一步最自然的方式就是用取模运算。取模运算可以保证输入任何一个整数，输出的整数索引值都在你的哈希表大小的范围内。

压缩哈希码，就是要把哈希码压缩为有限范围内的一个数组索引。有很多方式可以做到这点。下面将会介绍一些压缩哈希码的方法：

### 数字分析法

假设关键字集合中的每个关键字都是由s位数字组成(k1,k2,..., kn)，那么就从中提取分布均匀的若干位或它们的组合作为地址

```
H(key)=(last 7 digits of key) % n
```

> 比如:出生年月日
>
> 仅限于
>
> > 能预先估计出全体关键字的每一位上各种数字出现的频度
> >
> > 关键字中的某几部分总是相等的

### 平方取中法

若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响。

比如，214和234仅仅在十位有差别。通过平方取中法，我们可以得到214<sup>2</sup>=45796，234<sup>2</sup>=54756，每位数字差异相对变大了，

```
H(key) = (middle N digits of key^2) % n
```

### 构造方法小结

根据表中要存放的数据的关键码的特点来设计哈希压缩的方法。要让产生冲突的可能性最小。还要保证计算容易且速度快（如果一个哈希函数时间复杂度达到了O(n)，那就意味着插入，查找，删除的时间复杂度不低于O(n)，我干嘛不用二叉检索树呢）

特点：

- 确定性：**相同的输入导致相同的输出**
- 定义域**必须包含所有要存储的关键码**。值域必须在**哈希表索引的范围内**。

### 哈希冲突

当关键码的范围>哈希表的大小时，一定会出现的现象。

定义：key1 != key2, 但是 h(key1) == h(key2)（如果h(x)是哈希函数）

把索引值相同的不同关键码称为**同义词**。

解决哈希冲突的方法：

- 开地址法（又叫闭散列法）：在哈希表里头找一个其他的位置
- 开散列法（又叫闭地址法）：改变哈希表的结构，让哈希表的每个位置可以放下多个元素



## 开地址法

开地址法（又可以叫闭散列法）的核心就是放弃哈希函数求到的某个关键码的索引，转而寻找另一个位置存放数据。开地址法一共有3个方法。

### 线性探查法

如果哈希函数计算出的哈希索引是k，且k的位置不为空，就检查k+1的位置是否为空；不为空，则继续检查k+2,……；为空，则插入到k+1的位置。

如果检查到k+x+1时索引超出了线性表，就检查(k+x+2) % length 的位置是否为空（即从数组的开头重新查找）。

会产生“基本聚集”现象：即同义词较多的索引位置后面的位置全都会被占领。

#### 查找性能分析

搜索成功的平均搜索长度：找到哈希表中已经有的表项需要的平均探查长度

在查找一个存在于表中的表项时，平均需要查找几次。

计算方法：对于每一个表中已经有的表项，计算如果我要查找这一项，需要查找几次；把所有查找次数加起来除表项的数量



搜索不成功的平均搜索长度：表中不存在待查表项，但是找到插入位置需要的平均探查次数。

具体查找方法：利用哈希函数得到哈希索引，然后看看这个位置有没有元素。没有的话说明此表项不在，有表项且不是待探查元素的话，说明待探查元素可能在后头，需要往后查找；有表项且是待查找元素的话…那你就找到了。

计算方法：对于哈希表的每一个位置，假设有个关键码被哈希函数指到了这里，计算它需要几次探查才能真的找到空位置。（比如，对于哈希表中的空位置，探查次数为1次）。把所有的探查次数加起来除哈希表的表长。

#### 问题

1. 不能直接删除某个元素（即清空某个元素所在的位置），因为这可能导致其后的某些元素无法被找到。

   在查找某个元素时，空项代表着这个元素不存在；而清空某个元素可能会让查找它前面的元素时找到这个空项，从而错误地认为前面的元素不存在。这是相当不好的。

   删除时，一般采用打标记的方式；查找元素时，将这个位置视为有元素，且元素与待查找元素不相等。插入元素时，如果检索到了这个位置，那就认为此位置没有元素，把新的元素放到这里，覆盖之前的没删除的元素。

   逻辑删除的副作用：在进行多次删除之后，表面上表很满，实际上有很多位置没有利用。

### 平方探查

如果在哈希表的第k个位置发生了冲突，那么就依次试探其后继位置k+1<sup>2</sup>、k+2<sup>2</sup>、k+3<sup>2</sup>...

还有一种平方探查，如果在哈希表的第k个位置发生了冲突，那么就依次试探其后继位置k+1<sup>2</sup>、k-1<sup>2</sup>、k+2<sup>2</sup>、k-2<sup>2</sup>、k+3<sup>2</sup>...

#### 问题

1. 和线性探查一样，不能真正的删除元素

2. 相同的关键码会有这相同的探查序列（即搜索的位置会是一样的），会产生二次聚集

   这是由于平方探查查找的位置仅仅和关键码内容相关，仍然是有规律的。

### 双散列探查

当通过第一个哈希函数得到的哈希索引发生冲突之后，获得的下一个哈希索引应该是**第一个哈希索引加上通过第二个哈希函数求得的哈希索引之和**。

这种方法可以让两个不同的关键码（但他们在第一个哈希函数下的哈希索引相同）的探查序列不同。这是前两种探查都做得不到的，因此，他被广泛的应用。

第二个散列函数的要求：

1. 得到的哈希索引和第一个哈希函数不同

2. 所得到的哈希索引必须依赖于关键字

   如果哈希索引与输入的关键字无关，那它本质上也只是一种线性探查罢了。

3. 不能返回0（不能让哈希索引不变）

如果进行过一次这样的操作之后，`h1(x)+h2(x)` 位置仍然不是空的，那么就探查 `h1(x) + 2h*2(x)` 的位置。当然，如果索引超过下标，就采用循环数组那里的方法（求模）



## 开散列法

需要改变哈希表的元素，使得每个位置可以存放的元素从一个变为多个。

我们把能够放置多个元素的位置称为桶。而且，把同一个桶中（哈希索引一样的）的关键码称为同义词。

桶可以用线性表或者有序线性表实现。



## 对哈希的效率衡量：装载因子

由于完美的哈希函数并不总能找到，因此冲突的发生是无法避免的。

装载因子 **λ** 的定义为：哈希表中实际存放记录的个数/表的长度。

可以通过计算 λ 判断哈希表目前的状态（搜索代价怎么样）

### 开地址法的代价

线性探测法只有在装载因子 λ 小于0.3的时候，搜索代价才在2以内（才能满足O(1)）

平方探测法或者双散列法只在 λ 小于0.5时搜索代价较低。

### 开散列法的代价

开散列法的 λ 可以大于1（因为一个位置可以放多个记录）。开地址法的lambda最大就是1。

一般来说，开散列法在 λ<1 时的表现比较好。